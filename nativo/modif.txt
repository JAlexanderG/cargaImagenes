private Bitmap ConvertTo1bpp(Bitmap original)
{
    int width = original.Width;
    int height = original.Height;
    Bitmap bwImage = new Bitmap(width, height, PixelFormat.Format1bppIndexed);

    // ðŸ”¥ Bloquear bits de la imagen original y la de destino (1bpp)
    BitmapData originalData = original.LockBits(new Rectangle(0, 0, width, height), 
                                                ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
    BitmapData bwData = bwImage.LockBits(new Rectangle(0, 0, width, height), 
                                         ImageLockMode.WriteOnly, PixelFormat.Format1bppIndexed);

    int bytesPerPixel = 3; // 24bpp (RGB) â†’ 3 bytes por pÃ­xel
    int strideOriginal = originalData.Stride;
    int strideBw = bwData.Stride;
    int threshold = 128; // ðŸ”¥ Umbral para blanco/negro

    unsafe
    {
        byte* originalPtr = (byte*)originalData.Scan0;
        byte* bwPtr = (byte*)bwData.Scan0;

        for (int y = 0; y < height; y++)
        {
            byte pixelByte = 0;
            int bitIndex = 0;

            for (int x = 0; x < width; x++)
            {
                int index = (y * strideOriginal) + (x * bytesPerPixel);
                byte gray = (byte)(0.299 * originalPtr[index + 2] + 
                                   0.587 * originalPtr[index + 1] + 
                                   0.114 * originalPtr[index]);

                bool isBlack = gray < threshold;
                if (isBlack)
                {
                    pixelByte |= (byte)(1 << (7 - bitIndex));
                }

                bitIndex++;

                if (bitIndex == 8 || x == width - 1)
                {
                    int bwIndex = (y * strideBw) + (x / 8);
                    bwPtr[bwIndex] = pixelByte;
                    pixelByte = 0;
                    bitIndex = 0;
                }
            }
        }
    }

    bwImage.UnlockBits(bwData);
    original.UnlockBits(originalData);
    
    return bwImage;
}
