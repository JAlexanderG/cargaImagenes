private byte[] EnsureMaxSize(byte[] bmpData)
{
    using (var memoryStream = new MemoryStream(bmpData))
    using (var originalImage = new Bitmap(memoryStream))
    {
        int width = originalImage.Width;
        int height = originalImage.Height;
        int maxByteFirma = 2048;

        int valorTotal = (height * width) / 8;
        if (valorTotal > maxByteFirma)
        {
            int newWidth = (int)(Math.Sqrt(maxByteFirma * 8 * width / height)) + 200;
            int newHeight = (int)(newWidth * height / width);

            using (var resizedImage = new Bitmap(originalImage, new Size(newWidth, newHeight)))
            using (var outputMemoryStream = new MemoryStream())
            {
                // ðŸ”¥ Guardamos con el formato BMP original sin perder los pÃ­xeles negros.
                resizedImage.Save(outputMemoryStream, ImageFormat.Bmp);

                // ðŸ”¥ Verificamos si es mayor a 2048 bytes y aplicamos ajuste final
                byte[] finalData = outputMemoryStream.ToArray();

                if (finalData.Length > 2048)
                {
                    // ðŸ”¥ ReducciÃ³n sin comprometer la calidad
                    return ForceBitmapTo1bpp(finalData);
                }

                return finalData;
            }
        }
        else
        {
            return bmpData; // Si ya es menor a 2048 bytes, la dejamos sin cambios
        }
    }
}

// ðŸ”¥  Ajuste final para mantener los pÃ­xeles negros sin perder calidad
private byte[] ForceBitmapTo1bpp(byte[] bmpData)
{
    using (var ms = new MemoryStream(bmpData))
    using (var originalImage = new Bitmap(ms))
    {
        using (var binarized = ConvertTo1bpp(originalImage)) // ðŸ”¥ Convertimos de nuevo a 1bpp
        using (var outputStream = new MemoryStream())
        {
            binarized.Save(outputStream, ImageFormat.Bmp);
            return outputStream.ToArray();
        }
    }
}