private byte[] EnsureMaxSize(Bitmap image, int maxDataSize, int maxFileSize)
{
    int width = image.Width;
    int height = image.Height;

    // üî• 1. Primero intentamos guardar la imagen sin modificar
    using (var ms = new MemoryStream())
    {
        image.Save(ms, ImageFormat.Bmp);
        byte[] imageData = ms.ToArray();

        int bmpHeaderSize = 54;  // Tama√±o est√°ndar de la cabecera BMP
        int dataSize = imageData.Length - bmpHeaderSize;

        // ‚úÖ Si la imagen ya est√° dentro de los l√≠mites, la devolvemos sin modificar
        if (imageData.Length <= maxFileSize && dataSize <= maxDataSize)
            return imageData;
    }

    // üî• 2. Reducimos la imagen en pasos del 5% hasta alcanzar el tama√±o l√≠mite
    while (true)
    {
        width = (int)(width * 0.95);
        height = (int)(height * 0.95);

        // üö® No permitir reducir m√°s all√° de un tama√±o razonable
        if (width < 100 || height < 100)
        {
            Console.WriteLine("‚ö†Ô∏è La imagen no puede reducirse m√°s sin perder calidad.");
            break;  // Dejamos la imagen en el tama√±o m√°s cercano posible
        }

        using (var resizedImage = new Bitmap(image, new Size(width, height)))
        using (var ms = new MemoryStream())
        {
            resizedImage.Save(ms, ImageFormat.Bmp);
            byte[] imageData = ms.ToArray();

            int dataSize = imageData.Length - 54; // Excluir la cabecera BMP

            // ‚úÖ Si la imagen ya cumple los requisitos, la guardamos y terminamos
            if (imageData.Length <= maxFileSize && dataSize <= maxDataSize)
                return imageData;
        }
    }

    // üî• Si no logramos cumplir el l√≠mite, retornamos la versi√≥n m√°s reducida posible
    using (var ms = new MemoryStream())
    {
        image.Save(ms, ImageFormat.Bmp);
        return ms.ToArray();
    }
}