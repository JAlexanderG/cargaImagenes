private Bitmap ConvertTo8bpp(Bitmap original)
{
    // Crear un nuevo bitmap de 8bpp
    Bitmap bmp8bpp = new Bitmap(original.Width, original.Height, PixelFormat.Format8bppIndexed);
    ColorPalette palette = bmp8bpp.Palette;

    // ðŸ”¥ Generar una paleta de 256 tonos de gris
    for (int i = 0; i < 256; i++)
    {
        palette.Entries[i] = Color.FromArgb(i, i, i);
    }
    bmp8bpp.Palette = palette;

    // ðŸ”¥ Copiar pÃ­xeles manualmente usando LockBits
    Rectangle rect = new Rectangle(0, 0, original.Width, original.Height);
    BitmapData bmpData = bmp8bpp.LockBits(rect, ImageLockMode.WriteOnly, PixelFormat.Format8bppIndexed);
    BitmapData originalData = original.LockBits(rect, ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);

    int strideSrc = originalData.Stride;
    int strideDest = bmpData.Stride;

    unsafe
    {
        byte* ptrSrc = (byte*)originalData.Scan0;
        byte* ptrDest = (byte*)bmpData.Scan0;

        for (int y = 0; y < original.Height; y++)
        {
            for (int x = 0; x < original.Width; x++)
            {
                byte gray = (byte)(ptrSrc[0] * 0.11 + ptrSrc[1] * 0.59 + ptrSrc[2] * 0.3);
                ptrDest[x] = gray;

                ptrSrc += 3; // Avanzar en la imagen original (24bpp â†’ RGB usa 3 bytes por pÃ­xel)
            }
            ptrSrc += strideSrc - (original.Width * 3);
            ptrDest += strideDest - original.Width;
        }
    }

    bmp8bpp.UnlockBits(bmpData);
    original.UnlockBits(originalData);

    return bmp8bpp;
}
