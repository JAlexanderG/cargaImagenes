public class LeadToolsProcessor
{
    private const int MAXBYTE_FIRMA = 2048; // L√≠mite de tama√±o en bytes
    private const int MIN_WIDTH = 100; // Evitar que se haga demasiado peque√±a
    private const int MIN_HEIGHT = 100;

    public byte[] ProcessImage(Bitmap originalImage)
    {
        // üî• 1Ô∏è‚É£ CREAR "REGI√ìN FLOTANTE" (Equivalente a `Floater` en VB6)
        Rectangle floatRegion = new Rectangle(0, 0, originalImage.Width, originalImage.Height);
        using (Bitmap floaterImage = originalImage.Clone(floatRegion, originalImage.PixelFormat))
        {
            // üî• 2Ô∏è‚É£ AJUSTAR TAMA√ëO SIN PERDER CALIDAD
            Bitmap resizedImage = ResizeImage(floaterImage);

            // üî• 3Ô∏è‚É£ GUARDAR COMO BMP Y VERIFICAR TAMA√ëO
            byte[] finalImageData = SaveBmpAndCheckSize(resizedImage);

            return finalImageData;
        }
    }

    // **üî• 2Ô∏è‚É£ REDIMENSIONAR IMAGEN COMO `LEAD2.Size` en VB6**
    private Bitmap ResizeImage(Bitmap image)
    {
        int newWidth = image.Width;
        int newHeight = image.Height;

        // üî• Calcular nueva escala para cumplir con `MAXBYTE_FIRMA`
        double scaleFactor = Math.Sqrt((double)(MAXBYTE_FIRMA * 8) / (image.Width * image.Height)) + 0.1;
        newWidth = (int)(image.Width * scaleFactor);
        newHeight = (int)(image.Height * scaleFactor);

        // Evitar tama√±os demasiado peque√±os
        if (newWidth < MIN_WIDTH) newWidth = MIN_WIDTH;
        if (newHeight < MIN_HEIGHT) newHeight = MIN_HEIGHT;

        Bitmap resizedImage = new Bitmap(newWidth, newHeight);
        using (Graphics g = Graphics.FromImage(resizedImage))
        {
            g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;
            g.DrawImage(image, 0, 0, newWidth, newHeight);
        }

        return resizedImage;
    }

    // **üî• 3Ô∏è‚É£ GUARDAR COMO BMP Y ASEGURAR QUE NO EXCEDA LOS 2048 BYTES**
    private byte[] SaveBmpAndCheckSize(Bitmap image)
    {
        using (var ms = new MemoryStream())
        {
            image.Save(ms, ImageFormat.Bmp);
            byte[] bmpData = ms.ToArray();

            // üî• Si la imagen sigue superando los 2048 bytes, reducir m√°s
            while (bmpData.Length > MAXBYTE_FIRMA)
            {
                int newWidth = (int)(image.Width * 0.95);
                int newHeight = (int)(image.Height * 0.95);

                if (newWidth < MIN_WIDTH || newHeight < MIN_HEIGHT)
                    break; // Evitar reducir demasiado

                image = new Bitmap(image, new Size(newWidth, newHeight));
                using (var tempStream = new MemoryStream())
                {
                    image.Save(tempStream, ImageFormat.Bmp);
                    bmpData = tempStream.ToArray();
                }
            }

            return bmpData;
        }
    }
}