using System;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;

public class LeadToolsProcessor
{
    private const int MAXBYTE_FIRMA = 2048; // L√≠mite de tama√±o en bytes
    private const int MIN_WIDTH = 100; // Evitar que se haga demasiado peque√±a
    private const int MIN_HEIGHT = 100;

    public byte[] ProcessImage(Bitmap originalImage)
    {
        // üî• 1Ô∏è‚É£ Convertimos la imagen a 8bpp para compatibilidad con VB6
        using (Bitmap bwImage = ConvertTo8bpp(originalImage))
        {
            // üî• 2Ô∏è‚É£ Ajustamos el tama√±o sin perder calidad
            Bitmap resizedImage = ResizeImage(bwImage);

            // üî• 3Ô∏è‚É£ Guardamos como BMP y verificamos que no supere 2048 bytes
            byte[] finalImageData = SaveBmpAndCheckSize(resizedImage);

            return finalImageData;
        }
    }

    // **üî• 1Ô∏è‚É£ Convertir a 8bpp (Escala de grises con paleta de colores)**
    private Bitmap ConvertTo8bpp(Bitmap original)
    {
        Bitmap bmp8bpp = new Bitmap(original.Width, original.Height, PixelFormat.Format8bppIndexed);

        // üî• Configurar paleta de grises
        ColorPalette palette = bmp8bpp.Palette;
        for (int i = 0; i < 256; i++)
        {
            palette.Entries[i] = Color.FromArgb(i, i, i);
        }
        bmp8bpp.Palette = palette;

        using (Graphics g = Graphics.FromImage(bmp8bpp))
        {
            g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;
            g.DrawImage(original, new Rectangle(0, 0, original.Width, original.Height));
        }

        return bmp8bpp;
    }

    // **üî• 2Ô∏è‚É£ Ajustar Tama√±o de Imagen Sin Perder Calidad**
    private Bitmap ResizeImage(Bitmap image)
    {
        int newWidth = image.Width;
        int newHeight = image.Height;

        // üî• Calcular nueva escala para cumplir con `MAXBYTE_FIRMA`
        double scaleFactor = Math.Sqrt((double)(MAXBYTE_FIRMA * 8) / (image.Width * image.Height)) + 0.1;
        newWidth = (int)(image.Width * scaleFactor);
        newHeight = (int)(image.Height * scaleFactor);

        // Evitar tama√±os demasiado peque√±os
        if (newWidth < MIN_WIDTH) newWidth = MIN_WIDTH;
        if (newHeight < MIN_HEIGHT) newHeight = MIN_HEIGHT;

        Bitmap resizedImage = new Bitmap(newWidth, newHeight, PixelFormat.Format8bppIndexed);
        using (Graphics g = Graphics.FromImage(resizedImage))
        {
            g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;
            g.DrawImage(image, 0, 0, newWidth, newHeight);
        }

        return resizedImage;
    }

    // **üî• 3Ô∏è‚É£ Guardar como BMP y Verificar Tama√±o**
    private byte[] SaveBmpAndCheckSize(Bitmap image)
    {
        using (var ms = new MemoryStream())
        {
            image.Save(ms, ImageFormat.Bmp);
            byte[] bmpData = ms.ToArray();

            // üî• Si la imagen sigue superando los 2048 bytes, reducir m√°s
            while (bmpData.Length > MAXBYTE_FIRMA)
            {
                int newWidth = (int)(image.Width * 0.95);
                int newHeight = (int)(image.Height * 0.95);

                if (newWidth < MIN_WIDTH || newHeight < MIN_HEIGHT)
                    break; // Evitar reducir demasiado

                image = new Bitmap(image, new Size(newWidth, newHeight));
                using (var tempStream = new MemoryStream())
                {
                    image.Save(tempStream, ImageFormat.Bmp);
                    bmpData = tempStream.ToArray();
                }
            }

            return bmpData;
        }
    }
}
